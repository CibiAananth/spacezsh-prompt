#!/usr/bin/env zsh
# vim: ft=zsh fdm=marker foldlevel=0 sw=2 ts=2 sts=2 et

# Execution time end
function spaceship_exec_time_precmd_hook {
  [[ $SPACESHIP_EXEC_TIME_SHOW == false ]] && return

  SPACESHIP_EXEC_TIME_duration=$((EPOCHREALTIME - SPACESHIP_EXEC_TIME_start))

  # Reset start time
  SPACESHIP_EXEC_TIME_start=0x7FFFFFFF
}

# Hook to save exit code and prepare prompts
function prompt_spaceship_precmd() {
  # Retrieve exit code of last command to use in exit_code
  # Must be captured before any other command in prompt is executed
  # Must be the very first line in all entry prompt functions, or the value
  # will be overridden by a different command execution - do not move this line!
  RETVAL=$?
  RETVALS=( "$pipestatus[@]" )

  # hooks for section jobs
  # See https://unix.stackexchange.com/questions/68571/show-jobs-count-only-if-it-is-more-than-0
  # http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#index-jobstates
  # echo $jobstates
  _SS_DATA[jobs_running]=${(M)#${jobstates%%:*}:#running}
  _SS_DATA[jobs_suspended]=${(M)#${jobstates%%:*}:#suspended}

  # Stop measuring exec_time, must be the first precmd action
  spaceship_exec_time_precmd_hook

  # Restarts the async worker, in order to get an update-to-date shell environment
  if [[ "${_SS_DATA[async]}" == "true" ]]; then
    async_stop_worker "spaceship_section_worker"
    async_start_worker "spaceship_section_worker" #-n
    # setopt before call register to avoid callback by async_worker_eval
    async_worker_eval "spaceship_section_worker" 'setopt extendedglob'
    async_register_callback "spaceship_section_worker" "ss::async_callback"
  fi

  ss::build_section_cache
}

prompt_spaceship_precmd "$@"
